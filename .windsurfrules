# Overview

This project is a simple website that allows users to enter their GitHub username. The site then produces their contributions graph and allows the user to let it play a short melody based on their commit history.

The code is entirely written in TypeScript. I am using `pnpm` for package management.

# Project Structure

Root directories:

### `infrastructure/`

- Contains AWS CDK code for the project. Uses `aws-cdk-lib` version `2.182.0`.

- The primary components are a lambda function URL, along with a static S3 site with a cloudfront distribution.

### `frontend/`

- Contains the Svelte and SvelteKit code for the frontend.
  - `src/components/` contains the UI components for the frontend.
  - `src/lib/` contains the shared utilities and helpers for the frontend.
  - `src/routes/` contains the routes for the frontend.

### `backend/`

- Each directory within `/functions` is a separate lambda function.
  - `contributionFetcher/` contains the code which fetches and parses the GitHub contributions graph.

# Code Rules

## Code Structure and Organization
- **Follow the Single Responsibility Principle (SRP):** Each file, class, function, or module should have one clearly defined purpose. If a function or file grows too large or handles multiple unrelated tasks, split it into smaller, focused units.
- **Limit File and Function Length:** Aim for files to be under 300 lines and functions to be under 50 lines. If a file or function exceeds these limits, refactor it into smaller, more manageable pieces if possible.
- **Avoid Side Effects:** Ensure functions are pure where possible. If side effects are necessary (e.g., API calls, state updates), isolate them and document their impact clearly.

## Code Efficiency and Refactoring
- **Refactor Before Adding New Code:** When addressing a problem or adding a feature, first evaluate if existing code can be simplified, reused, or improved to solve the issue. Avoid introducing unnecessary new code.
- **Remove Dead Code:** Regularly scan for and remove unused variables, functions, or imports. If code is no longer needed, delete it rather than leaving it commented out.
- **Keep Code DRY (Don't Repeat Yourself):** Identify opportunities to consolidate duplicate logic into reusable functions, utilities, or components.
- **Use Composition Over Inheritance:** Favor composition (e.g., React hooks, utility functions) over inheritance to keep code modular and avoid tight coupling.

## Best Practices and Consistency
- **Adhere to TypeScript Best Practices:** Use strict typing, avoid `any` types, and leverage interfaces or types to enforce contracts between components, functions, and modules.
- **Modularize Code:** Break down complex logic into smaller modules or utilities that can be imported and reused across the app.
- **Use Modern TypeScript Features:** Leverage features like optional chaining (`?.`), nullish coalescing (`??`), and template literal types to write cleaner, safer code.
- **Keep Dependencies Up-to-Date:** Always check for and use the latest stable versions of libraries (e.g., React, TypeScript, etc.) and tools. Reference official documentation or npm trends to ensure compatibility and security.

## Error Handling and Edge Cases
- **Implement Thorough Error Handling:** Every function that can fail (e.g., API calls, file operations) must include proper error handling using try/catch blocks or proper error types.
- **Handle Edge Cases:** Consider and handle edge cases such as null/undefined values, empty arrays, invalid user input, or network failures. Document these cases in comments if needed.
- **Use TypeScript for Safety:** Use type guards, discriminated unions, or exhaustive switch statements to ensure all possible cases are handled in conditional logic.
- **Provide Meaningful Error Messages:** When throwing or logging errors, include context (e.g., what failed, why it failed) to aid debugging.

## Maintainability and Scalability
- **Write Self-Documenting Code:** Use descriptive names for variables, functions, and files. Avoid cryptic abbreviations unless they are industry-standard (e.g., `i` for loop index).
- **Add Comments for Complex Logic:** While code should be self-explanatory, add comments to explain *why* complex logic exists, not just *what* it does.
- **Plan for Scalability:** Design code with future growth in mind. For example, avoid hardcoding values that might need to change, and prefer configuration files or environment variables.
- **Use Design Patterns Where Applicable:** Apply patterns like Factory, Singleton, or Observer if they simplify the architecture or solve recurring problems. Don't over-engineer with patterns unnecessarily.

## Testing and Validation
- **Write Testable Code:** Structure code to be easily testable by keeping functions pure, minimizing dependencies, and using dependency injection where appropriate.
- **Include Unit Test Suggestions:** For critical logic (e.g., utilities, API handlers), suggest unit tests using frameworks like Jest or Vitest to validate functionality.
- **Validate Inputs:** Always validate inputs (e.g., user input, API responses) before processing them. Use libraries like Zod or Joi for schema validation where appropriate.

## Performance and Optimization
- **Optimize for Performance:** Avoid unnecessary re-renders in React (e.g., use `useMemo`, `useCallback`), minimize API calls, and lazy-load heavy resources.
- **Avoid Overfetching Data:** When working with APIs, fetch only the data needed for the task. Use pagination, filtering, or GraphQL if applicable.
- **Minimize Bundle Size:** Be cautious when adding new dependencies. Use tree-shaking, lazy loading, and code-splitting to keep the bundle size small.

## Enforcement and Accountability
- **Self-Review Generated Code:** After generating code, perform a self-audit to ensure it adheres to these rules before presenting it. Suggest improvements if needed.
- **Ask for Feedback:** If unsure about a design decision or implementation, ask the user for clarification or preferences (e.g., "Would you prefer a different approach for handling this API call?").
- **Track Rule Violations:** If a rule is violated due to constraints or requirements, document the reason and suggest how to address it in the future.